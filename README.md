## 로또

### 주요 기능

- **구매 금액 입력**

  - 사용자로부터 구입 금액을 입력받음.

- **로또 수량 계산**

  - 구매 금액을 기반으로 구매 가능한 로또 수량 계산.

- **로또 발행**

  - 구매 수량에 맞게 로또 발행.
  - 1~45 사이의 숫자로 구성된 로또 번호 생성.
  - 중복되지 않는 6개의 숫자로 로또 발행.
  - 각 로또 번호를 오름차순으로 출력.

- **당첨 번호 및 보너스 번호 입력**

  - 사용자로부터 쉼표로 구분된 6개의 당첨 번호 입력받기.
  - 사용자로부터 보너스 번호 1개를 입력받기.

- **당첨 결과 계산**

  - 발행된 로또 번호와 당첨 번호를 비교하여 일치 개수 확인.
  - 일치 개수에 따라 결정.

- **당첨 내역 및 수익률 출력**
  - 일치한 숫자 개수, 당첨 개수, 상금을 정리하여 출력.
  - 수익률은 소수점 둘째 자리까지 반올림하여 출력.

### 예외 처리

0. **예외 발생 시 출력 형식**

   - 예외 상황 발생 시 `[ERROR]`로 시작하는 메시지 출력.

1. **구매 금액 입력 오류**

   - 입력 값이 비어 있을 경우 예외 처리.
   - 숫자가 아닌 값 입력 시 예외 처리.
   - 1,000원 미만의 금액 입력 시 예외 처리.
   - 1,000원으로 나누어떨어지지 않는 금액 입력 시 예외 처리.

2. **로또 및 당첨 번호 입력 오류**

   - 입력 값이 비어 있거나 ,사이에 공백만 존재하는 경우 예외 처리.
   - 숫자와 `,` 이외의 문자가 포함된 경우 예외 처리.
   - 입력된 번호의 개수가 6개가 아닌 경우 예외 처리.
   - 중복된 번호 입력 시 예외 처리.
   - 번호가 1~45 범위를 벗어나는 경우 예외 처리.

3. **보너스 번호 입력 오류**

   - 입력 값이 비어 있을 경우 예외 처리.
   - 숫자가 아닌 값 입력 시 예외 처리.
   - 보너스 번호가 1~45 범위를 벗어나는 경우 예외 처리.
   - 보너스 번호가 당첨 번호와 중복되는 경우 예외 처리.

## 주요 구현 방법 및 고민

### 설계

- 입력을 받고, 파싱하고, 유효성 검사를 진행한 후 Game 클래스에 넘기는 큰 흐름은 이전과 같았습니다. 이번에는 Game 클래스에 넘기기 전에 중간에 구매한 로또와 당첨 로또를 별도의 클래스로 정의한 다음 Game에 넘겼습니다.

- 이렇게 구분한 이유는 요구사항이 복잡해짐에 따라 각 객체의 역할과 성격을 명확히 구분하는 것이 코드의 가독성과 유지보수에 유리할 것이라고 판단했기 때문입니다. 특히, 당첨 로또에는 보너스 번호가 포함되므로 클래스로 분리하여 관리하는 것이 더 적합하다고 느꼈습니다.

- 두 클래스는 모두 Lotto 클래스의 인스턴스를 내부적으로 가지고 있어, 로또라는 개념을 유지하면서도 구매한 로또와 당첨 로또의 역할을 분리할 수 있었습니다. 이로 인해 Game 클래스는 단순히 결과를 계산하고 출력하는 역할에 집중할 수 있게 되었습니다.

### 접근 제어자

- 외부에 굳이 노출되지 않아야 할 요소들은 모두 private으로 접근 제어자로 설정했습니다.
- private으로 설정한 필드를 외부에서 가져다 사용할 때 getNumbers()와 같은 메서드를 만드는 것과 getter로 구현하는 것 사이에서 고민이 되었습니다. 다른 분들은 어떻게 get 관련 메소드를 사용하는지 알아보고 싶습니다.
- 마지막으로 외부에서 사용하지 않는 메소드는 private 접근 제어자로 설정하다보니, 각 메소드에 대한 테스트 작성에 어려움을 겪었습니다. 프라이빗 메소드는 직접적으로 테스트할 수 없으므로, 해당 메소드를 사용하는 퍼블릭 메서드를 통해 간접적으로 검증했습니다. 하지만, 각 메소드에 대한 테스트 코드를 작성하지 못하므로, 이에 대해 다른 분들은 어떻게 생각하는지 이야기를 나눠보고 싶습니다.

### 당첨 결과 관리

- 로또 당첨 결과는 3개 일치부터 6개 일치까지 각 등수마다 당첨 로또 수, 상금, 출력 텍스트라는 공통된 속성을 가집니다. 이를 객체로만 관리하려다 보니 코드가 다소 복잡해 보였습니다.
- 그래서 이러한 속성들을 하나의 형태로 관리할 수 있도록 WinningResult 클래스를 도입하여 통일된 형태로 관리했습니다 이로 인해 코드가 더 읽기 쉬워졌으며, 각 등수의 당첨 정보를 수정할 때 더 유연하게 처리할 수 있게 되었습니다.

### 유효성 검사

- 유효성 검사를 위해 각각의 검증 로직을 개별 함수로 분리하고, 이 함수를 배열에 담아 순서대로 실행하는 방식을 택했습니다. 이를 통해 각 검증 로직을 독립적으로 관리하고, 필요한 검증만을 조합하여 유연하게 사용할 수 있었습니다. 하지만, 이 방식이 최선일지에 대한 고민도 남아 있습니다. 특히, 더 효율적이고 가독성을 높이는 방법이 있는지 탐색해보고 싶습니다.

- 일반적으로 유효성 검사를 위해 파싱이 선행되어야 하기 때문에 입력값을 파싱한 후 유효성 검사를 진행하는 구조로 설계했습니다. 하지만, 이렇게 구성하다 보니 비어있는 값에 대한 예외처리가 다소 어려워졌습니다. 이를 해결하기 위해, 파싱 과정에서 비어 있거나 ,로 연결된 값들 중 빈 값이 존재할 경우 이를 null로 처리했습니다. 이후 유효성 검증 함수에서 null을 만나면 빈 값이 있음을 확인하고 적절한 예외 메시지를 출력하도록 설정했습니다. 파싱과 유효성 검사를 명확히 구분함으로써 각 함수가 하나의 책임만 갖도록 노력하였습니다.

### 매직 넘버 제거

- 이전 과제 코드 리뷰에서 지적받은 부분을 반영하여 이번에는 변경될 가능성이 있는 값들을 상수화했습니다.
- 상수화를 통해 비즈니스 로직이 변경될 때 해당 상수만 수정하면 되므로 코드의 유연성과 유지보수성을 크게 높일 수 있었습니다.
