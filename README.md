# :school: 우아한테크코스 7기 프리코스 3주차 미션 - 로또

### 3주차 미션 진행시 학습 목표
* 관련 함수를 묶어 클래스를 만들고, 객체들이 협력하여 하나의 큰 기능을 수행하도록 한다.
* 클래스와 함수에 대한 단위 테스트를 통해 의도한 대로 정확하게 작동하는 영역을 확보한다.
* 2주 차 공통 피드백을 최대한 반영한다.
<details>
<summary>2주차 공통 피드백 자세히 보기</summary>

#### 1. README.md를 상세히 작성한다.
미션 저장소의 README.md는 소스 코드 이전에 프로젝트의 개요를 소개하는 문서다. 이 문서를 통해 해당 프로젝트가 어떤 프로젝트인지, 주요 기능이 무엇인지 소개할 수 있다. 효과적으로 작성하기 위해 마크다운 문법을 검색하여 학습하고, 이를 활용해 README.md를 작성해 본다.

#### 2. 기능 목록을 재검토한다.
기능 목록을 작성할 때 클래스 설계와 구현, 메서드 설계와 구현 같은 상세한 내용은 포함하지 않는다. 클래스 이름이나 메서드 시그니처, 반환값 등은 언제든지 변경될 수 있기 때문이다. 구현해야 할 기능 목록을 중심으로 작성하되, 정상적인 경우뿐만 아니라 예외 상황도 함께 정리한다. 예외 상황은 시작 단계에서 파악하기 어려우므로, 기능을 구현하면서 지속적으로 업데이트하는 것이 좋다.

#### 3. 기능 목록을 업데이트한다.
README.md 파일의 기능 목록은 구현 과정에서 변경될 수 있다. 시작부터 모든 기능을 완벽하게 정리해야 한다는 부담을 갖기보다는, 기능을 구현하면서 문서를 지속적으로 업데이트하는 것을 목표로 한다. 이를 통해 죽은 문서가 아닌 살아있는 문서로 유지될 수 있도록 노력해 보자.

#### 4. 값을 하드 코딩하지 않는다.
코드 내에서 문자열이나 숫자 값을 하드 코딩하지 않는다. 대신 상수(const)를 정의하고 의미 있는 이름을 부여하여 해당 값이 어떤 역할을 하는지 명확히 드러낸다. 구글에 "javascript const" 등의 키워드로 검색하여 상수 구현 방법을 학습하고 코드에 적용해 본다.

#### 5. 구현 순서도 코딩 컨벤션이다.
클래스는 필드, 생성자, 메서드 순으로 작성한다. 
```javascript
class A {
    필드
    생성자
    메서드
}
```

#### 6. 한 메서드가 한 가지 기능만 담당하게 한다.
함수의 길이가 길어진다면 여러 기능을 한 함수에서 처리하려는 신호일 가능성이 높다. 예를 들어, 안내 문구 출력, 사용자 입력 처리, 유효값 검증 등의 작업을 한 함수에 모두 포함하는 대신, 이를 각기 다른 함수로 분리해 본다.
```javascript
const userInput = () => {
  MissionUtils.Console.readLine("경주할 자동차 이름을 입력하세요(이름은 쉼표(,)를 기준으로 구분): ", (input) => {
    const carNames = input.split(",");
    for (int index = 0; index < carNames.length; index++) {
      if (carNames[index].length < 1 || carNames[index].length > 5) {
        throw new Error("[ERROR] 자동차 이름은 1자 이상 5자 이하만 가능합니다.");
      }
    }
    return carNames;
  });
};

```

#### 7. 메서드가 한 가지 기능을 하는지 확인하는 기준을 세운다.
여러 메서드에서 중복되는 코드가 있다면 이를 별도 메서드로 분리하는 것을 고려한다. 메서드의 길이가 길어지면 여러 기능을 포함하고 있을 가능성이 커지므로, 15라인이 넘지 않도록 구현하면 의식적으로 메서드를 분리하는 연습을 할 수 있다.

#### 8. 테스트를 작성하는 이유에 대해 본인의 경험을 토대로 정리해본다.
테스트를 작성하면 기능의 정확성을 점검함을 넘어 코드의 즉각적인 피드백을 받을 수 있다. 테스트 작성 과정을 통해 구현한 기능의 문제를 빠르게 발견할 수 있을 뿐만 아니라, 코드의 구조와 의도를 명확히 이해하는 데도 도움을 받을 수 있다. 학습 도구로도 활용할 수 있는데, 수 많은 테스트의 장점 중 본인이 가장 공감하는 작성 이유를 작성해 본다.

#### 9. 처음부터 큰 단위의 테스트를 만들지 않는다.
테스트의 핵심 목적 중 하나는 코드에 대해 빠르고 자주 피드백을 받는 것이다. 처음부터 큰 단위의 테스트를 작성하게 되면, 작성한 코드의 문제를 발견하기까지 시간이 오래 걸린다. 따라서 문제를 작게 나누어 핵심 기능부터 작게 테스트를 만들어 가는 것이 효과적이다.
##### 큰 단위의 테스트
* 자동차 경주 게임을 시작하여, 사용자가 이름과 진행 횟수를 입력하고, 게임을 진행한 후 결과를 확인한다.
##### 작은 단위의 테스트
* 무작위 값이 4 이상이면 자동차가 전진한다.
* 무작위 값이 3 이하이면 자동차가 전진하지 않는다.

#### 10. JavaScript에서 객체를 만드는 다양한 방법을 이해하고 사용한다.
JavaScript에서는 클래스를 사용하는 방법 이외에도 객체를 만드는 다양한 방법이 존재한다. 다양한 객체 생성 방식을 익히면 유연하게 코드를 설계할 수 있다.

</details>

## :clipboard: 구현할 기능 목록

### 1. 사용자 입력
- [X] 로또 구입 금액 입력 (구입 금액은 1,000원 단위로 입력받는다.)
- [X] 당첨 번호 입력 (6개의 숫자이며 번호는 1부터 45까지, 쉼표[',']를 통해 구분한다.)
- [X] 보너스 번호 입력

#### '로또 구입 금액' 입력에 대한 예외처리
- [X] '로또 구입 금액'이 1,000 단위가 아닐 경우 [ERROR]
- [X] '로또 구입 금액'이 1,000 아래일 경우 [ERROR]
- [X] '로또 구입 금액'이 공백일 경우 [ERROR]
- [X] '로또 구입 금액'이 숫자가 아닐 경우 [ERROR]

#### '당첨 번호' 입력에 대한 예외처리
- [X] '당첨 번호'가 1부터 45 사이의 숫자가 아닐 경우 [ERROR]
- [X] '당첨 번호'가 숫자가 아닐 경우 [ERROR]
- [X] '당첨 번호'가 음수일 경우 [ERROR]
- [X] '당첨 번호' 6개의 숫자가 중복될 경우 [ERROR]

#### '보너스 번호' 입력에 대한 예외처리
- [X] '보너스 번호'가 숫자가 아닐 경우 [ERROR]
- [X] '보너스 번호'가 음수일 경우 [ERROR]
- [X] '보너스 번호'가 공백일 경우 [ERROR]
- [X] '보너스 번호'가 '당첨 번호'와 중복될 경우 [ERROR]

### 2. 로또 발행 및 당첨 내역, 수익율 출력
- [X] 입력한 '로또 구입 구액'의 해당하는 만큼 로또를 발행 및 출력한다. 로또 1장의 가격은 1,000원 이다.
- [X] 당첨 내역을 출력한다.
- [X] 당첨 결과를 통하여 수익율을 추출하여 출력한다.

## :file_folder: 패키지 구조 및 파일명
```
- src
  - 📂 contants
  - - 📜 errorMessages.js
  - - 📜 lottoMessages.js
  - 📂 controllers
  - - 📜 LottoController.js
  - 📂 errors
  - - 📜 AppError.js
  - - 📜 BonusNumberError.js
  - - 📜 LottoError.js
  - - 📜 PurchaseAmountError.js
  - - 📜 WinningNumbersError.js
  - 📂 models
  - - 📜 BonusNumber.js
  - - 📜 Lotto.js
  - - 📜 Prize.js
  - - 📜 PurchaseAmount.js
  - - 📜 WinningNumbers.js
  - 📂 utils
  - - 📜 generateAutoLottoNumbers.js
  - 📂 views
  - - 📜 InputView.js
  - - 📜 OutputView.js
  - App.js
  - index.js
```

### LottoController.js [로또의 메인이 되는 클래스]
* lottoProcess
- 로또의 전체적인 프로세스를 담당하는 함수입니다.
* getInputPurchaseAmount
- 사용자에게 '로또 구입 금액'을 입력받아 this.#purchaseLottosCount에 할당합니다.
* getLottos
- '로또 구입 금액' / 1000 의 값을 통해 랜덤 로또 함수를 생성하여 this.#lottos에 할당합니다.
* getInputWinningNumbers
- 사용자에게 '당첨 금액'을 입력받아 this.#winningNumbers에 할당합니다.
* getPrizeResult
- 사용자에게 '보너스 번호'을 입력받아 this.#bonusNumber에 할당합니다.
* printRacingCarWinners
- '로또 번호', '당첨 번호', '보너스 번호'를 통해 당첨 내역, 수익율을 계산한 뒤 각각 this.#pize, this.#rateReturn에 할당합니다.

### PurchaseAmount.js [로또 구입 금액 값을 담당하는 클래스]
* getPurchaseAmount
- '로또 구입 금액 / 1000'을 #purchaseAmount에 할당하고 유효성 검사를 실행한 뒤 #purchaseAmount / 1000의 값을 리턴합니다.
* validate
- 입력받은 '로또 구입 금액'에 대한 각각의 유효성 검사를 실행합니다.
* formatLottoNumbers
- 발행된 로또 출력형식을 위한 format 함수입니다.

### Lotto.js [로또 발행 번호 값을 담당하는 클래스]
* getLottos
- 구입한 로또 수만큼 1부터 45까지의 6개 숫자를 랜덤으로 생성하여 #numbers에 할당합니다.
* validate
- 구입한 로또에 대한 각각의 유효성 검사를 실행합니다.

### WinningNumbers.js [당첨 번호 값을 담당하는 클래스]
* getWinningNumbers
- 입력받은 당첨 번호를 오름차순 한 뒤 #winningNumbers에 할당합니다.
* validate
- 당첨 번호에 대한 각각의 유효성 검사를 실행합니다.

### BonusNumber.js [보너스 번호 값을 담당하는 클래스]
* getBonusNumber
- 입력받은 보너스 번호와 당첨 번호를 통해 보너스 번호를 #bonusNumber에 할당합니다.
- 보너스 번호에 대한 각각의 유효성 검사를 실행하며, 당첨 번호를 통해 중복 검사를 실행합니다.

### Prize.js [당첨 내역, 수익율 값을 담당하는 클래스]
* getPrize
- 로또 발행 번호, 당첨 번호, 보너스 번호를 통해 일치하는 로또 카운트, 일치하는 보너스 번호 카운트를 계산한 뒤 Prize.LOTTO_STATISTICS의 count 값을 증가하여 리턴합니다.
* getRateReturn
- prize 데이터를 통해 수익율을 계산합니다.
* getPrizeRankCounts
- 로또 카운트, 보너스 번호 카운트를 통해 로또 발행번호와 일치할 시 카운트를 증가시킵니다.
* incrementRankCount
- 증가된 카운트를 이용하여 Prize.LOTTO_STATISTICS에 count 값을 증가시킵니다.
* isRankConditionMet
- 로또 카운트와, 보너스 카운트를 구분하는 함수입니다.

## 테스트 결과
<div style="display: flex; flex-direction: row;">
    <img src="https://github.com/user-attachments/assets/cb3b78bf-157f-4f79-b131-8375ba567279" style="width: 50%;">
    <img src="https://github.com/user-attachments/assets/1e00f9d2-fafd-472f-8e50-602b2e1b2f38" style="width: 50%;">
</div>

## :computer: 커밋 메세지 컨벤션
```
- Allowed <type>
- feat (feature)
- fix (bug fix)
- docs (documentation)
- style (formatting, missing semi colons, …)
- refactor
- test (when adding missing tests)
- chore (maintain)
```

## :high_brightness: 기능 및 프로그래밍 요구 사항

### 기능 요구 사항
간단한 로또 발매기를 구현한다.
* 로또 번호의 숫자 범위는 1~45까지이다.
* 1개의 로또를 발행할 때 중복되지 않는 6개의 숫자를 뽑는다.
* 당첨 번호 추첨 시 중복되지 않는 숫자 6개와 보너스 번호 1개를 뽑는다.
* 당첨은 1등부터 5등까지 있다. 당첨 기준과 금액은 아래와 같다.
  1등: 6개 번호 일치 / 2,000,000,000원
  2등: 5개 번호 + 보너스 번호 일치 / 30,000,000원
  3등: 5개 번호 일치 / 1,500,000원
  4등: 4개 번호 일치 / 50,000원
  5등: 3개 번호 일치 / 5,000원
* 로또 구입 금액을 입력하면 구입 금액에 해당하는 만큼 로또를 발행해야 한다.
* 로또 1장의 가격은 1,000원이다.
* 당첨 번호와 보너스 번호를 입력받는다.
* 사용자가 구매한 로또 번호와 당첨 번호를 비교하여 당첨 내역 및 수익률을 출력하고 로또 게임을 종료한다.
  사용자가 잘못된 값을 입력할 경우 "[ERROR]"로 시작하는 메시지와 함께 Error를 발생시키고 해당 메시지를 출력한 다음 해당 지점부터 다시 입력을 받는다.

### 프로그래밍 요구 사항 1
* Node.js 20.17.0 버전에서 실행 가능해야 한다.
* 프로그램 실행의 시작점은 App.js의 run()이다.
* package.json 파일은 변경할 수 없으며, 제공된 라이브러리와 스타일 라이브러리 이외의 외부 라이브러리는 사용하지 않는다.
프로그램 종료 시 process.exit()를 호출하지 않는다.
* 프로그래밍 요구 사항에서 달리 명시하지 않는 한 파일, 패키지 등의 이름을 바꾸거나 이동하지 않는다.
* 자바스크립트 코드 컨벤션을 지키면서 프로그래밍한다.
* 기본적으로 JavaScript Style Guide를 원칙으로 한다.

### 프로그래밍 요구 사항 2
* indent(인덴트, 들여쓰기) depth를 3이 넘지 않도록 구현한다. 2까지만 허용한다.
예를 들어 while문 안에 if문이 있으면 들여쓰기는 2이다.
힌트: indent(인덴트, 들여쓰기) depth를 줄이는 좋은 방법은 함수(또는 메서드)를 분리하면 된다.
* 3항 연산자를 쓰지 않는다.
* 함수(또는 메서드)가 한 가지 일만 하도록 최대한 작게 만들어라.
* Jest를 이용하여 정리한 기능 목록이 정상적으로 작동하는지 테스트 코드로 확인한다.

### 프로그래밍 요구 사항 3
* 함수(또는 메서드)의 길이가 15라인을 넘어가지 않도록 구현한다.
* 함수(또는 메서드)가 한 가지 일만 잘 하도록 구현한다.
* else를 지양한다.
때로는 if/else, when문을 사용하는 것이 더 깔끔해 보일 수 있다. 어느 경우에 쓰는 것이 적절할지 스스로 고민해 본다.
힌트: if 조건절에서 값을 return하는 방식으로 구현하면 else를 사용하지 않아도 된다.
* 구현한 기능에 대한 단위 테스트를 작성한다. 단, UI(System.out, System.in, Scanner) 로직은 제외한다.
단위 테스트 작성이 익숙하지 않다면 LottoTest를 참고하여 학습한 후 테스트를 작성한다.
